<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Alex&#39;s personal blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Alex&#39;s personal blog">
<meta property="og:locale">
<meta property="article:author" content="Alex">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Alex's personal blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Alex's personal blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java注解和反射与动态代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-09 17:33:54 / Modified: 18:02:01" itemprop="dateCreated datePublished" datetime="2021-09-09T17:33:54+08:00">2021-09-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##Java  注解和反射与动态代理</p>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><blockquote>
<p>在定义注解时，注解类也能够使用其他的注解声明。对注解类型进行注解的注解类，我们称之为 metaannotation（元注解）。一般的，我们在定义自定义注解时，需要指定的元注解有两个 ：<br>在定义注解时，注解类也能够使用其他的注解声明。对注解类型进行注解的注解类，我们称之为 &gt;metaannotation（元注解）。一般的，我们在定义自定义注解时，需要指定的元注解有两个 ：</p>
</blockquote>
<blockquote>
<p><strong>@Target</strong><br>注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以应用于注解类型。</li>
<li>ElementType.CONSTRUCTOR 可以应用于构造函数。</li>
<li> ElementType.FIELD 可以应用于字段或属性。</li>
<li> ElementType.LOCAL_VARIABLE 可以应用于局部变量。</li>
<li>ElementType.METHOD 可以应用于方法级注解。</li>
<li> ElementType.PACKAGE 可以应用于包声明。</li>
<li> ElementType.PARAMETER 可以应用于方法的参数。</li>
<li> ElementType.TYPE 可以应用于类的任何元素。</li>
</ul>
<p><strong>@Retention</strong><br>注解指定标记注解的存储方式：</p>
<ul>
<li>RetentionPolicy.SOURCE - 标记的注解仅保留在源级别中，并被编译器忽略。</li>
<li>RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但 Java 虚拟机(JVM)会忽略。</li>
<li>RetentionPolicy.RUNTIME - 标记的注解由 JVM 保留，因此运行时环境可以使用它。<br>@Retention 三个值中 SOURCE &lt; CLASS &lt; RUNTIME，即CLASS包含了SOURCE，RUNTIME包含SOURCE、<br>CLASS。下文会介绍他们不同的应用场景。</li>
</ul>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// @Target(ElementType.TYPE)//只能在类上标记该注解</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)//只能在属性和方法上标记</span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //注解保留在源码这中</span><br><span class="line">public @interface ViewInject &#123;</span><br><span class="line">    //限制输入的是资源id</span><br><span class="line">    @IdRes int value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注解类型元素"><a href="#注解类型元素" class="headerlink" title="注解类型元素"></a>注解类型元素</h4><blockquote>
<p>在上文元注解中，允许在使用注解时传递参数。我们也能让自定义注解的主体包含 annotation type element (注解 类型元素) 声明，它们看起来很像方法，可以定义可选的默认值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)</span><br><span class="line"> @Retention(RetentionPolicy.SOURCE) public </span><br><span class="line"> @interface Alex &#123;</span><br><span class="line">  String value(); //无默认值 </span><br><span class="line">  int age() default 1; //有默认值 </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：在使用注解时，如果定义的注解中的类型元素无默认值，则必须进行传值。</strong></p>
<h4 id="注解应用场景"><a href="#注解应用场景" class="headerlink" title="注解应用场景"></a>注解应用场景</h4><blockquote>
<p>按照@Retention 元注解定义的注解存储方式，注解可以被在三种场景下使用：</p>
</blockquote>
<h3 id="RetentionPolicy-SOURCE"><a href="#RetentionPolicy-SOURCE" class="headerlink" title="RetentionPolicy.SOURCE"></a>RetentionPolicy.SOURCE</h3><p><strong>RetentionPolicy.SOURCE 作用于源码级别的注解，可提供给IDE语法检查、APT等场景使用，在类中使用 SOURCE 级别的注解，其编译之后的class中会被丢弃。</strong></p>
<h4 id="IDE语法检查"><a href="#IDE语法检查" class="headerlink" title="IDE语法检查"></a>IDE语法检查</h4><blockquote>
<p>如：我们定义方法 test ，此方法接收参数 teacher 需要在：ALEX、BOB;中选择一个。如果使用枚举能够实现<br>为:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Teacher&#123; </span><br><span class="line">   ALEX,BOB </span><br><span class="line">&#125;</span><br><span class="line">public void test(Teacher teacher) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而现在为了进行内存优化，我们现在不再使用枚举，则方法定义为：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final int ALEX = 1; </span><br><span class="line">public static final int BOB = 2; </span><br><span class="line">public void test(int teacher) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>然而此时，调用 test 方法由于采用基本数据类型int，将无法进行类型限定。此时使用@IntDef增加自定义注解</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static final int ALEX = 1; </span><br><span class="line">public static final int BOB = 2; </span><br><span class="line">@IntDef(value = &#123;MAN, WOMEN&#125;) //限定为ALEX，BOB</span><br><span class="line">@Target(ElementType.PARAMETER) //作用于参数的注解 </span><br><span class="line">@Retention(RetentionPolicy.SOURCE) //源码级别注解 </span><br><span class="line">public @interface Teacher &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test(@Teacher int teacher) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此时，我们再去调用 test 方法，如果传递的参数不是 LANCE 或者 ALVIN 则会显示 Inspection 警告(编译不会报<br>错)。</strong></p>
<h4 id="APT注解处理器"><a href="#APT注解处理器" class="headerlink" title="APT注解处理器"></a>APT注解处理器</h4><p><strong>APT全称为：”Anotation Processor Tools”，意为注解处理器。</strong>顾名思义，其用于处理注解。编写好的Java源文<br>件，需要经过 javac 的编译，翻译为虚拟机能够加载解析的字节码Class文件。注解处理器是 javac 自带的一个工<br>具，用来在编译时期扫描处理注解信息。你可以为某些注解注册自己的注解处理器。 注册的注解处理器由 javac<br>调起，并将注解信息传递给注解处理器进行处理。</p>
<blockquote>
<p>注解处理器是对注解应用最为广泛的场景。在Glide、EventBus3、Butterknifer、Tinker、ARouter等等常用<br>框架中都有注解处理器的身影。但是你可能会发现，这些框架中对注解的定义并不是 SOURCE 级别，更多的<br>是 CLASS 级别，别忘了：CLASS包含了SOURCE，RUNTIME包含SOURCE、CLASS。</p>
</blockquote>
<h3 id="RetentionPolicy-CLASS"><a href="#RetentionPolicy-CLASS" class="headerlink" title="RetentionPolicy.CLASS"></a>RetentionPolicy.CLASS</h3><blockquote>
<p><strong>定义为 CLASS 的注解，会保留在class文件中，但是会被虚拟机忽略(即无法在运行期反射获取注解</strong>)。此时完全符合<br>此种注解的应用场景为字节码操作。如：<strong>AspectJ</strong>、热修复Roubust中应用此场景。</p>
</blockquote>
<h3 id="RetentionPolicy-RUNTIME"><a href="#RetentionPolicy-RUNTIME" class="headerlink" title="RetentionPolicy.RUNTIME"></a>RetentionPolicy.RUNTIME</h3><blockquote>
<p>注解保留至运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。</p>
</blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>反射就是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法;对于任意一个对象,都能够调用它的任意方法和属性;并且能改变它的属性。</strong></p>
<blockquote>
<p>Java反射机制主要提供了以下功能：</p>
</blockquote>
<ul>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时获取或者修改任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法（属性）</li>
</ul>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><blockquote>
<p>反射始于Class，Class是一个类，封装了当前对象所对应的类的信息.</p>
</blockquote>
<h5 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h5><blockquote>
<ol>
<li>通过类名获取 类名.class</li>
<li>通过对象获取 对象名.getClass() </li>
<li>通过全类名获取 Class.forName(全类名) classLoader.loadClass(全类名)</li>
</ol>
</blockquote>
<h5 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h5><blockquote>
<p>一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的<br>isInstance() 方法来判断是否为某个类的实例，它是一个 native 方法：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native boolean isInstance(Object obj);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断是否为某个类的类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAssignableFrom(Class&lt;?&gt; cls)</span><br></pre></td></tr></table></figure>

<h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p><strong>通过反射来生成对象主要有两种方式</strong>。</p>
<ul>
<li>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class; </span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。<br>/获取String所对应的Class对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class; </span><br><span class="line">//获取String类带一个String参数的构造器</span><br><span class="line">Constructor constructor = c.getConstructor(String.class); </span><br><span class="line">//根据构造器创建实例</span><br><span class="line">Object obj = constructor.newInstance(&quot;23333&quot;); </span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<h5 id="获取构造器信息"><a href="#获取构造器信息" class="headerlink" title="获取构造器信息"></a>获取构造器信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Constructor getConstructor(Class[] params) -- 获得使用特殊的参数类型的public构造函数(包括父类）</span><br><span class="line"> </span><br><span class="line">Constructor[] getConstructors() -- 获得类的所有公共构造函数 Constructor </span><br><span class="line"></span><br><span class="line">getDeclaredConstructor(Class[] params) -- 获得使用特定参数类型的构造函数(包括私有) </span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructors() -- 获得类的所有构造函数(与接入级别无关)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的</strong><br>一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public T newInstance(Object ... initargs)</span><br></pre></td></tr></table></figure>

<h5 id="获取类的成员变量（字段）信息"><a href="#获取类的成员变量（字段）信息" class="headerlink" title="获取类的成员变量（字段）信息"></a>获取类的成员变量（字段）信息</h5><p><strong>获得字段信息的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field getField(String name) -- 获得命名的公共字段 </span><br><span class="line"></span><br><span class="line">Field[] getFields() -- 获得类的所有公共字段 </span><br><span class="line"></span><br><span class="line">Field getDeclaredField(String name) -- 获得类声明的命名的字段</span><br><span class="line"></span><br><span class="line">Field[] getDeclaredFields() -- 获得类声明的所有字段</span><br></pre></td></tr></table></figure>

<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。 invoke 方法的原型为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br></pre></td></tr></table></figure>

<h5 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h5><p><strong>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference 其中的Array类为<br>java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newInstance(Class&lt;?&gt; componentType, int length);</span><br></pre></td></tr></table></figure>

<h3 id="动态代理原理"><a href="#动态代理原理" class="headerlink" title="动态代理原理"></a>动态代理原理</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><blockquote>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
</blockquote>
<p>目的：</p>
<blockquote>
<ol>
<li>通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；</li>
<li>通过代理对象对访问进行控制；</li>
</ol>
</blockquote>
<p>代理模式一般会有三个角色：</p>
<blockquote>
<p><strong>抽象角色</strong>：指代理角色和真实角色对外提供的公共方法，一般为一个接口<br><strong>真实角色</strong>：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业务逻辑在此。<br><strong>代理角色</strong>：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理！</p>
</blockquote>
<blockquote>
<p><strong>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。</strong><br><strong>静态代理，一对一则会出现时静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现扩展能力差的问题。</strong></p>
</blockquote>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><blockquote>
<p>在运行时再创建代理类和其实例，因此显然效率更低。要完成这个场景，需要在运行期动态创建一个Class。JDK提供了 Proxy 来完成这件事情。基本使用如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色 </span><br><span class="line">interface Api &#123;</span><br><span class="line"> void test(String a); </span><br><span class="line">&#125;</span><br><span class="line">//真实角色</span><br><span class="line">class ApiImpl&#123; </span><br><span class="line"> @Override public void test(String a) &#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;真实实现：&quot; + a);</span><br><span class="line">   </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">//创建真实角色实例</span><br><span class="line">ApiImpl api = new ApiImpl();</span><br><span class="line">//JDK动态代理: </span><br><span class="line">Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]&#123;Api.class&#125;, </span><br><span class="line"> //JDK实现只能代理接口 </span><br><span class="line">new InvocationHandler() &#123; </span><br><span class="line">      @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; </span><br><span class="line">        //执行真实对象方法</span><br><span class="line">        return method.invoke(api, args); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>实际上， Proxy.newProxyInstance 会创建一个Class，与静态代理不同，这个Class不是由具体的.java源文件编译<br>而来，即没有真正的文件，只是在内存中按照Class格式生成了一个Class</strong>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/lqfGaara/ViewInject">基于java反射和注解简单实现butterknife</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/Java%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Java%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">Java泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-09 17:31:27 / Modified: 18:02:01" itemprop="dateCreated datePublished" datetime="2021-09-09T17:31:27+08:00">2021-09-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java  泛型"></a>Java  泛型</h3><p>泛型的好处</p>
<blockquote>
<ol>
<li>代码更健壮（编译器警告，不会出现ClassCastExceptiion）;</li>
<li>代码更加简洁（不用强转）；</li>
<li>代码更灵活，复用。</li>
</ol>
</blockquote>
<h4 id="泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法"><a href="#泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法" class="headerlink" title="泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法"></a>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</h4><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test&lt;T&gt;&#123; </span><br><span class="line">    //key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public get(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    public T set()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    //定义一个泛型接口</span><br><span class="line">public interface Person&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="当实现泛型接口的类，未传入泛型实参时"><a href="#当实现泛型接口的类，未传入泛型实参时" class="headerlink" title="当实现泛型接口的类，未传入泛型实参时"></a><strong>当实现泛型接口的类，未传入泛型实参时</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Student&lt;T&gt; implements Person&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="当实现泛型接口的类，传入泛型实参时："><a href="#当实现泛型接口的类，传入泛型实参时：" class="headerlink" title="当实现泛型接口的类，传入泛型实参时："></a><strong>当实现泛型接口的类，传入泛型实参时：</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Person&lt;String&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型方法的基本介绍</span><br><span class="line"> * @param tClass 传入的泛型实参</span><br><span class="line"> * @return T 返回值为T类型</span><br><span class="line"> * 说明：</span><br><span class="line"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span><br><span class="line"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span><br><span class="line"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span><br><span class="line"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T get(Class&lt;T&gt; tClass)&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h5><p><strong>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">System.out.println(l1.getClass() == l2.getClass());</span><br><span class="line"></span><br><span class="line">打印的结果为 true 是因为 List&lt;String&gt;和 List&lt;Integer&gt;在 jvm 中的 Class 都是 List.class。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">puclic   interface Test&lt;T&gt;&#123;</span><br><span class="line">   public  Test(T object);</span><br><span class="line">&#125;</span><br><span class="line">在编译阶段会被擦除成  object</span><br><span class="line"></span><br><span class="line">pulicl  interfcae  Test&lt;T extends String&gt;&#123;</span><br><span class="line">public  Test(T object);</span><br><span class="line">&#125;</span><br><span class="line">在编译阶段会被擦除成  String </span><br></pre></td></tr></table></figure>

<p><strong>我们现在可以下结论了，在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <T>则会被转译成普通的 Object 类型，如果指定了上限如 <T extends String>则类型参数就被替换成类型上限。</strong></p>
<p>//<strong>泛型擦除在编译期间，其实常量池里面保留了泛型信息，所哟我们可以通过反射获取泛型信息。常见retrofit中获取泛型类型传入的JavaBean  对象</strong></p>
<h4 id="Java泛型原理？什么是泛型擦除机制？"><a href="#Java泛型原理？什么是泛型擦除机制？" class="headerlink" title="Java泛型原理？什么是泛型擦除机制？"></a>Java泛型原理？什么是泛型擦除机制？</h4><p> <strong>Java 的泛型是JDK5引入的特性，为了向下兼容，虚拟机其实不支持泛型，所以Java实现的是一种违泛型机制，也就是说Java在编译期擦除了所有的泛型信息，这样Java就不需要产生新的类型到字节码，所有的泛型类型最终都是一种原始类型，在java运行时根本就不存在泛型信息。</strong></p>
<h4 id="Java编译器具体是如何擦除泛型的？"><a href="#Java编译器具体是如何擦除泛型的？" class="headerlink" title="Java编译器具体是如何擦除泛型的？"></a>Java编译器具体是如何擦除泛型的？</h4><blockquote>
<ol>
<li>检查泛型类型，获取目标类型；</li>
<li>擦除类型变量，并替换为限定类型   ；如果泛型类型的类型没有变量设定<T>,则用&gt;Object作为原始类型，如果限定（T exends Xclass）则用Xclass作为原始类型；如果有多个限定（T extends XClass &amp;XClass2）则使用第一个边界XClas作为原始类。</li>
<li>在必要时插入类型转换以保持类型安全；</li>
<li>生成桥方法以在扩展时保持多态性。</li>
</ol>
</blockquote>
<h4 id="使用泛型以及泛型擦除带来的影响（副作用）"><a href="#使用泛型以及泛型擦除带来的影响（副作用）" class="headerlink" title="使用泛型以及泛型擦除带来的影响（副作用）"></a>使用泛型以及泛型擦除带来的影响（副作用）</h4><blockquote>
<ol>
<li>泛型类型不能使用基本类型 ；（类型ArrayList<String>泛型擦除后就是 ArrayList<Object> ，但是Object类型不能存放基本类型）</li>
<li>不能使用instanceof 运算符（类型ArrayList<String>泛型擦除后就是 ArrayList<Object> ，泛型信息String 不存在了，所以没法使用instanceof）</li>
<li>泛型在静态方法静态类中的问题（因为泛型类中的泛型参数的实例化是定义在泛型类对象（比如ArrayList<String>的时候指定的，二静态成员是不需要使用对象来调用的，所以对象都没有创建，如何确定在这个泛型参数是什么。））</li>
<li> 泛型类型中的方法冲突（因为擦除后两个方法变成一样了）</li>
<li>没法创建泛型实例</li>
<li>没有泛型数组（因为数字组是协变的） T  []  arry =new T[3] //不允许</li>
</ol>
</blockquote>
<h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><blockquote>
<p>？ extends X  表示类型的上界，类型参数是X的子类<br>？ super X  表示类型的下界，类型参数是X的超类(父类或者父类的父类)</p>
</blockquote>
<h4 id="？-extends-X"><a href="#？-extends-X" class="headerlink" title="？ extends X"></a>？ extends X</h4><blockquote>
<p>set方法是不允许被调用的，会出现编译错误<br>get方法则没问题，会返回一个X类型的值。<br>道理很简单，？ extends X  表示类型的上界，类型参数是X的子类，那么可以肯定的说，get方法返回的一定是个X（不管是X或者X的子类）编译器是可以确定知道的。但是set方法只知道传入的是个X，至于具体是X的那个子类，不知道。<br><strong>总结：主要用于安全地访问数据，可以访问X及其子类型，并且不能写入非null的数据。</strong></p>
</blockquote>
<h4 id="？-super-X"><a href="#？-super-X" class="headerlink" title="？ super X"></a>？ super X</h4><blockquote>
<p>表示传递给方法的参数，必须是X的超类（父类或者父类的父类 包括X本身）<br>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法可以被调用的，且能传入的参数只能是X或者X的子类;</p>
</blockquote>
<blockquote>
<p>get方法只会返回一个Object类型的值。</p>
</blockquote>
<blockquote>
<p>？ super  X  表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的超类，所以get方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X和X的子类可以安全的转型为X。<br><strong>总结：主要用于安全地写入数据，可以写入X及其子类型。</strong></p>
</blockquote>
<h4 id="无限定的通配符"><a href="#无限定的通配符" class="headerlink" title="无限定的通配符 ?"></a>无限定的通配符 ?</h4><blockquote>
<p>表示对类型没有什么限制，可以把？看成所有类型的父类，如Pair&lt; ?&gt;；<br>比如：<br>ArrayList<T> al=new ArrayList<T>(); 指定集合元素只能是T类型<br>ArrayList<?> al=new ArrayList<?>();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。<br>在使用上：<br>？ getFirst() ： 返回值只能赋给 Object，；<br>void setFirst(?) ： setFirst 方法不能被调用， 甚至不能用 Object 调用；</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/Android%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Android%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9/" class="post-title-link" itemprop="url">Android编译插桩</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-09 17:11:13 / Modified: 18:02:01" itemprop="dateCreated datePublished" datetime="2021-09-09T17:11:13+08:00">2021-09-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><h4 id="编译插桩的应用场景"><a href="#编译插桩的应用场景" class="headerlink" title="编译插桩的应用场景"></a>编译插桩的应用场景</h4><blockquote>
<p><strong>代码生成</strong> 除了 Dagger、ButterKnife 这些常用的注解生成框架，Protocol Buffers、数据库 ORM 框架也都会在编译过程生成代码。<br><strong>代码监控</strong> 除了网络监控和耗电监控，我们可以利用编译插桩技术实现各种各样的性能监控。<br><strong>代码修改</strong><br><strong>代码分析</strong><br>对于代码监控、代码修改以及代码分析这三个场景，一般采用操作字节码的方式。可以操作“.class”的 Java 字节码，也可以操作“.dex”的 Dalvik 字节码，这取决于我们使用的插桩方法。</p>
</blockquote>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p><img src="./1.png" alt="Alt text"></p>
<h4 id="编译插桩的量种方法"><a href="#编译插桩的量种方法" class="headerlink" title="编译插桩的量种方法"></a>编译插桩的量种方法</h4><p>AspectJ 和 ASM 框架的输入和输出都是 Class 文件，它们是我们最常用的 Java 字节码处理框架。</p>
<h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p><a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/">AspectJ</a>是 Java 中流行的 AOP（aspect-oriented programming）编程扩展框架。<br><strong>基于AspectJ的扩展工具：</strong><br><a target="_blank" rel="noopener" href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">沪江</a><br><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/hugo">hugo</a></p>
<h5 id="AspectJ的优势"><a href="#AspectJ的优势" class="headerlink" title="AspectJ的优势"></a>AspectJ的优势</h5><blockquote>
<p><strong>成熟稳定:</strong> AspectJ 作为从 2001 年发展至今的框架，它已经很成熟，一般不用考虑插入的字节码正确性的问题。<br>**使用简单:**它可以在方法（包括构造方法）被调用的位置、在方法体（包括构造方法）的内部、在读写变量的位置、在静态代码块内部、在异常处理的位置等前后，插入自定义的代码，或者直接将原位置的代码替换为自定义的代码。</p>
</blockquote>
<h5 id="AspectJ的缺点"><a href="#AspectJ的缺点" class="headerlink" title="AspectJ的缺点"></a>AspectJ的缺点</h5><blockquote>
<ol>
<li><strong>切入点固定：</strong>AspectJ 只能在一些固定的切入点来进行操作，如果想要进行更细致的操作则无法完成，它不能针对一些特定规则的字节码序列做操作。</li>
<li><strong>正则表达式：</strong>AspectJ 的匹配规则是类似正则表达式的规则，比如匹配 Activity 生命周期的 onXXX 方法，如果有自定义的其他以 on 开头的方法也会匹配到。</li>
<li><strong>性能较低：</strong>AspectJ 在实现时会包装自己的一些类，逻辑比较复杂，不仅生成的字节码比较大，而且对原函数的性能也会有所影响。</li>
</ol>
</blockquote>
<p><strong>使用 AspectJ 有两种方式：</strong></p>
<ol>
<li>完全使用 AspectJ 的语言开发；</li>
<li>使用 AspectJ 注解，完全的使用纯 Java 开发。</li>
</ol>
<p><strong>下面是注解的使用方式：</strong><br><strong>参考示例：</strong><br><a target="_blank" rel="noopener" href="https://github.com/yxhuangCH/AndroidAopDemo">demo链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static final String POINTCUT_METHOD =</span><br><span class="line">     &quot;execution(@org.android10.gintonic.annotation.DebugTrace * *(..))&quot;;</span><br><span class="line"> private static final String POINTCUT_CONSTRUCTOR =</span><br><span class="line">     &quot;execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))&quot;;</span><br><span class="line">     </span><br><span class="line"> @Pointcut(POINTCUT_METHOD)</span><br><span class="line"> public void methodAnnotatedWithDebugTrace() &#123;&#125;</span><br><span class="line"> @Pointcut(POINTCUT_CONSTRUCTOR)</span><br><span class="line"> public void constructorAnnotatedDebugTrace() &#123;&#125;</span><br><span class="line"></span><br><span class="line"> @Around(&quot;methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()&quot;)</span><br><span class="line"> public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">   // joint 对象信息</span><br><span class="line">   MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">   String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">   String methodName = methodSignature.getName();</span><br><span class="line"></span><br><span class="line">   final StopWatch stopWatch = new StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   Object result = joinPoint.proceed();</span><br><span class="line">   stopWatch.stop();</span><br><span class="line">   DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><p><a target="_blank" rel="noopener" href="https://asm.ow2.io/">ASM</a>就是一个可以实现 100% 场景的 Java 字节码操作框架。<br>ASM的特点：</p>
<ol>
<li><strong>操作灵活</strong>操作起来很灵活，可以根据需求自定义修改、插入、删除。上手难。</li>
<li><strong>上手比较难</strong>需要对 Java 字节码有比较深入的了解。</li>
</ol>
<p><strong>基于 ASM 的字节码处理工具：</strong><br><a target="_blank" rel="noopener" href="https://github.com/Leaking/Hunter">Hunter</a><br><a target="_blank" rel="noopener" href="https://github.com/BryanSharp/hibeaver">Hibeaver</a></p>
<p><strong>Transform</strong></p>
<blockquote>
<p>Transform是gradle构建的时候从class文件转换到dex文件期间处理class文件的一套方案，ClassVisitor可以是看做处理单个class文件，Transform可以处理一系列的class文件：从查找到所有class文件，到交给ClassVisitor和MethodVisitor处理后，再到重新覆盖原来的class文件这么一个流程。</p>
</blockquote>
<p><strong>ClassVisitor</strong></p>
<blockquote>
<p>用于访问 Java 类文件。</p>
</blockquote>
<p> <strong>ClassReader</strong></p>
<blockquote>
<p>用于将 Java 类文件转换成 ClassVisitor 能访问的结构。它有四个构造函数，分别支持 byte[]、InputStream、File Path 三种输入方式。</p>
</blockquote>
<p><strong>ClassWriter</strong></p>
<blockquote>
<p>用于生成符合 JVM 规范的字节码文件，可以单独使用进行生成字节码文件，也可以配合 ClassReader 或 ClassVisitor 适配器进行现有类文件的修改。ClassWriter 提供了两种创建方式，一种是单独创建，另一种是以 ClassReader 作为参数。</p>
</blockquote>
<p><strong>参考示例</strong><br><a target="_blank" rel="noopener" href="https://github.com/lqfGaara/AOPUiAdapter">demo链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 处理Jar中的class文件</span><br><span class="line">     */</span><br><span class="line">    static void handleJarInputs(JarInput jarInput, TransformOutputProvider outputProvider) throws IOException &#123;</span><br><span class="line">        if (jarInput.getFile().getAbsolutePath().endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">            String jarName = jarInput.getName();</span><br><span class="line">            String md5Name = DigestUtils.md5Hex(jarInput.getFile().getAbsolutePath());</span><br><span class="line">            if (jarName.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">                jarName = jarName.substring(0, jarName.length() - 4);</span><br><span class="line">            &#125;</span><br><span class="line">            JarFile jarFile = new JarFile(jarInput.getFile());</span><br><span class="line">            Enumeration enumeration = jarFile.entries();</span><br><span class="line">            File tmpFile = new File(jarInput.getFile().getParent() + File.separator + &quot;classes_temp.jar&quot;);</span><br><span class="line">            if (tmpFile.exists()) &#123;</span><br><span class="line">                tmpFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">            JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(tmpFile));</span><br><span class="line">            while (enumeration.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry jarEntry = (JarEntry) enumeration.nextElement();</span><br><span class="line">                String entryName = jarEntry.getName();</span><br><span class="line">                ZipEntry zipEntry = new ZipEntry(entryName);</span><br><span class="line">                InputStream inputStream = jarFile.getInputStream(jarEntry);</span><br><span class="line">                //插桩class</span><br><span class="line">                if (checkClassFile(entryName)) &#123;</span><br><span class="line">                    //class文件处理</span><br><span class="line">                    System.out.println(&quot;----------- deal with jar class file &lt;&quot; + entryName + &quot;&gt;&quot;);</span><br><span class="line">                    jarOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                    ClassReader classReader = new ClassReader(IOUtils.toByteArray(inputStream));</span><br><span class="line">                    ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">                    ClassVisitor cv = new TestClassAdapter(classWriter);</span><br><span class="line">                    classReader.accept(cv, EXPAND_FRAMES);</span><br><span class="line">                    byte[] code = classWriter.toByteArray();</span><br><span class="line">                    jarOutputStream.write(code);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    jarOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                    jarOutputStream.write(IOUtils.toByteArray(inputStream));</span><br><span class="line">                &#125;</span><br><span class="line">                jarOutputStream.closeEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            //结束</span><br><span class="line">            jarOutputStream.close();</span><br><span class="line">            jarFile.close();</span><br><span class="line">            File dest = outputProvider.getContentLocation(jarName + md5Name,</span><br><span class="line">                    jarInput.getContentTypes(), jarInput.getScopes(), Format.JAR);</span><br><span class="line">            FileUtils.copyFile(tmpFile, dest);</span><br><span class="line">            tmpFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public  class TestClassAdapter extends ClassVisitor &#123;</span><br><span class="line">    public TestClassAdapter(ClassVisitor cv) &#123;</span><br><span class="line">        super(Opcodes.ASM5,cv);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">        MethodVisitor methodVisitor=super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        if (FilterUtil.isMatchingMethod(name,desc))&#123;</span><br><span class="line">            return methodVisitor==null?null:new TestMethodAdapter(methodVisitor);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return methodVisitor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestMethodAdapter extends MethodVisitor implements Opcodes &#123;</span><br><span class="line">    public TestMethodAdapter(MethodVisitor mv) &#123;</span><br><span class="line">        super(Opcodes.ASM5,mv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitCode() &#123;</span><br><span class="line">        super.visitCode();</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;android/support/v4/app/FragmentActivity&quot;, &quot;getApplication&quot;, &quot;()Landroid/app/Application;&quot;, false);</span><br><span class="line">        mv.visitIntInsn(Opcodes.SIPUSH, 360);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;lqf/com/myutils2/ScreenUtils&quot;, &quot;setCustomDebsity&quot;, &quot;(Landroid/app/Activity;Landroid/app/Application;I)V&quot;, false);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码工具</strong><br><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline">ASM Bytecode Outline</a><br><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/14860-asm-bytecode-viewer-support-kotlin">ASM Bytecode Viewer Support Kotlin</a></p>
<p><img src="./1626252123888.png" alt="Alt text"></p>
<p><strong>参考文献</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/innost/article/details/49387395">https://blog.csdn.net/innost/article/details/49387395</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yxhuang2008/article/details/94193201">https://blog.csdn.net/yxhuang2008/article/details/94193201</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_dsw/article/details/111112109">https://blog.csdn.net/Mr_dsw/article/details/111112109</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E5%9B%9B-JNI%E4%B8%AD%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E5%9B%9B-JNI%E4%B8%AD%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" class="post-title-link" itemprop="url">Android JNI开发步骤四(JNI内存泄漏)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-09 17:11:13 / Modified: 18:02:01" itemprop="dateCreated datePublished" datetime="2021-09-09T17:11:13+08:00">2021-09-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="JNI-编程简介"><a href="#JNI-编程简介" class="headerlink" title="JNI 编程简介"></a>JNI 编程简介</h4><p>JNI，Java Native Interface，是 native code 的编程接口。JNI 使 Java 代码程序可以与 native code 交互——在 Java 程序中调用 native code；在 native code 中嵌入 Java 虚拟机调用 Java 的代码。<br>JNI 编程在软件开发中运用广泛，其优势可以归结为以下几点：</p>
<blockquote>
<ol>
<li>利用 native code 的平台相关性，在平台相关的编程中彰显优势。</li>
<li>对 native code 的代码重用。</li>
<li>native code 底层操作，更加高效。</li>
</ol>
</blockquote>
<p>然而任何事物都具有两面性，JNI 编程也同样如此。程序员在使用 JNI 时应当认识到 JNI 编程中如下的几点弊端，扬长避短，才可以写出更加完善、高性能的代码：</p>
<blockquote>
<ol>
<li>从 Java 环境到 native code 的上下文切换耗时、低效。</li>
<li>JNI 编程，如果操作不当，可能引起 Java 虚拟机的崩溃。<br>3, JNI 编程，如果操作不当，可能引起内存泄漏。</li>
</ol>
</blockquote>
<h4 id="JAVA-中的内存泄漏"><a href="#JAVA-中的内存泄漏" class="headerlink" title="JAVA 中的内存泄漏"></a>JAVA 中的内存泄漏</h4><p>JAVA 编程中的内存泄漏，从泄漏的内存位置角度可以分为两种：JVM 中 Java Heap 的内存泄漏；JVM 内存中 native memory 的内存泄漏。</p>
<h5 id="Java-Heap-的内存泄漏"><a href="#Java-Heap-的内存泄漏" class="headerlink" title="Java Heap 的内存泄漏"></a>Java Heap 的内存泄漏</h5><p>Java 对象存储在 JVM 进程空间中的 Java Heap 中，Java Heap 可以在 JVM 运行过程中动态变化。如果 Java 对象越来越多，占据 Java Heap 的空间也越来越大，JVM 会在运行时扩充 Java Heap 的容量。如果 Java Heap 容量扩充到上限，并且在 GC 后仍然没有足够空间分配新的 Java 对象，便会抛出 out of memory 异常，导致 JVM 进程崩溃。<br>Java Heap 中 out of memory 异常的出现有两种原因</p>
<blockquote>
<ol>
<li>程序过于庞大，致使过多 Java 对象的同时存在；</li>
<li>程序编写的错误导致 Java Heap 内存泄漏。<br>多种原因可能导致 Java Heap 内存泄漏。JNI 编程错&gt;误也可能导致 Java Heap 的内存泄漏。</li>
</ol>
</blockquote>
<h5 id="JVM-中-native-memory-的内存泄漏"><a href="#JVM-中-native-memory-的内存泄漏" class="headerlink" title="JVM 中 native memory 的内存泄漏"></a>JVM 中 native memory 的内存泄漏</h5><p>从操作系统角度看，JVM 在运行时和其它进程没有本质区别。在系统级别上，它们具有同样的调度机制，同样的内存分配方式，同样的内存格局。<br>JVM 进程空间中，Java Heap 以外的内存空间称为 JVM 的 native memory。进程的很多资源都是存储在 JVM 的 native memory 中，例如载入的代码映像，线程的堆栈，线程的管理控制块，JVM 的静态数据、全局数据等等。也包括 JNI 程序中 native code 分配到的资源。<br>在 JVM 运行中，多数进程资源从 native memory 中动态分配。当越来越多的资源在 native memory 中分配，占据越来越多 native memory 空间并且达到 native memory 上限时，JVM 会抛出异常，使 JVM 进程异常退出。而此时 Java Heap 往往还没有达到上限。<br>多种原因可能导致 JVM 的 native memory 内存泄漏。例如 JVM 在运行中过多的线程被创建，并且在同时运行。JVM 为线程分配的资源就可能耗尽 native memory 的容量。<br>JNI 编程错误也可能导致 native memory 的内存泄漏。对这个话题的讨论是本文的重点。<br>回页首</p>
<h5 id="JNI-编程中明显的内存泄漏"><a href="#JNI-编程中明显的内存泄漏" class="headerlink" title="JNI 编程中明显的内存泄漏"></a>JNI 编程中明显的内存泄漏</h5><p>JNI 编程实现了 native code 和 Java 程序的交互，因此 JNI 代码编程既遵循 native code 编程语言的编程规则，同时也遵守 JNI 编程的文档规范。在内存管理方面，native code 编程语言本身的内存管理机制依然要遵循，同时也要考虑 JNI 编程的内存管理。<br>本章简单概括 JNI 编程中显而易见的内存泄漏。从 native code 编程语言自身的内存管理，和 JNI 规范附加的内存管理两方面进行阐述。</p>
<h5 id="Native-Code-本身的内存泄漏"><a href="#Native-Code-本身的内存泄漏" class="headerlink" title="Native Code 本身的内存泄漏"></a>Native Code 本身的内存泄漏</h5><p>JNI 编程首先是一门具体的编程语言，或者 C 语言，或者 C++，或者汇编，或者其它 native 的编程语言。每门编程语言环境都实现了自身的内存管理机制。因此，JNI 程序开发者要遵循 native 语言本身的内存管理机制，避免造成内存泄漏。以 C 语言为例，当用 malloc() 在进程堆中动态分配内存时，JNI 程序在使用完后，应当调用 free() 将内存释放。总之，所有在 native 语言编程中应当注意的内存泄漏规则，在 JNI 编程中依然适应。<br>Native 语言本身引入的内存泄漏会造成 native memory 的内存，严重情况下会造成 native memory 的 out of memory。</p>
<h5 id="Global-Reference-引入的内存泄漏"><a href="#Global-Reference-引入的内存泄漏" class="headerlink" title="Global Reference 引入的内存泄漏"></a>Global Reference 引入的内存泄漏</h5><p>JNI 编程还要同时遵循 JNI 的规范标准，JVM 附加了 JNI 编程特有的内存管理机制。<br>JNI 中的 Local Reference 只在 native method 执行时存在，当 native method 执行完后自动失效。这种自动失效，使得对 Local Reference 的使用相对简单，native method 执行完后，它们所引用的 Java 对象的 reference count 会相应减 1。不会造成 Java Heap 中 Java 对象的内存泄漏。<br>而 Global Reference 对 Java 对象的引用一直有效，因此它们引用的 Java 对象会一直存在 Java Heap 中。程序员在使用 Global Reference 时，需要仔细维护对 Global Reference 的使用。如果一定要使用 Global Reference，务必确保在不用的时候删除。就像在 C 语言中，调用 malloc() 动态分配一块内存之后，调用 free() 释放一样。否则，Global Reference 引用的 Java 对象将永远停留在 Java Heap 中，造成 Java Heap 的内存泄漏。<br>回页首</p>
<h4 id="JNI-编程中潜在的内存泄漏——对-LocalReference-的深入理解"><a href="#JNI-编程中潜在的内存泄漏——对-LocalReference-的深入理解" class="headerlink" title="JNI 编程中潜在的内存泄漏——对 LocalReference 的深入理解"></a>JNI 编程中潜在的内存泄漏——对 LocalReference 的深入理解</h4><p>Local Reference 在 native method 执行完成后，会自动被释放，似乎不会造成任何的内存泄漏。但这是错误的。对 Local Reference 的理解不够，会造成潜在的内存泄漏。<br>本章重点阐述 Local Reference 使用不当可能引发的内存泄漏。引入两个错误实例，也是 JNI 程序员容易忽视的错误；在此基础上介绍 Local Reference 表，对比 native method 中的局部变量和 JNI Local Reference 的不同，使读者深入理解 JNI Local Reference 的实质；最后为 JNI 程序员提出应该如何正确合理使用 JNI Local Reference，以避免内存泄漏。</p>
<h5 id="错误实例-1"><a href="#错误实例-1" class="headerlink" title="错误实例 1"></a>错误实例 1</h5><p>在某些情况下，我们可能需要在 native method 里面创建大量的 JNI Local Reference。这样可能导致 native memory 的内存泄漏，如果在 native method 返回之前 native memory 已经被用光，就会导致 native memory 的 out of memory。<br>在代码清单 1 里，我们循环执行 count 次，JNI function NewStringUTF() 在每次循环中从 Java Heap 中创建一个 String 对象，str 是 Java Heap 传给 JNI native method 的 Local Reference，每次循环中新创建的 String 对象覆盖上次循环中 str 的内容。str 似乎一直在引用到一个 String 对象。整个运行过程中，我们看似只创建一个 Local Reference。<br>执行代码清单 1 的程序，第一部分为 Java 代码，nativeMethod(int i) 中，输入参数设定循环的次数。第二部分为 JNI 代码，用 C 语言实现了 nativeMethod(int i)。</p>
<h5 id="清单-1-Local-Reference-引发内存泄漏"><a href="#清单-1-Local-Reference-引发内存泄漏" class="headerlink" title="清单 1. Local Reference 引发内存泄漏"></a>清单 1. Local Reference 引发内存泄漏</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> Java 代码部分</span><br><span class="line"> class TestLocalReference &#123; </span><br><span class="line"> private native void nativeMethod(int i); </span><br><span class="line"> public static void main(String args[]) &#123; </span><br><span class="line">         TestLocalReference c = new TestLocalReference(); </span><br><span class="line">         //call the jni native method </span><br><span class="line">         c.nativeMethod(1000000); </span><br><span class="line"> &#125;  </span><br><span class="line"> static &#123; </span><br><span class="line"> //load the jni library </span><br><span class="line"> System.loadLibrary(&quot;StaticMethodCall&quot;); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> JNI 代码，nativeMethod(int i) 的 C 语言实现</span><br><span class="line"> #include&lt;stdio.h&gt; </span><br><span class="line"> #include&lt;jni.h&gt; </span><br><span class="line"> #include&quot;TestLocalReference.h&quot;</span><br><span class="line"> JNIEXPORT void JNICALL Java_TestLocalReference_nativeMethod </span><br><span class="line"> (JNIEnv * env, jobject obj, jint count) </span><br><span class="line"> &#123; </span><br><span class="line"> jint i = 0; </span><br><span class="line"> jstring str; </span><br><span class="line"></span><br><span class="line"> for(; i&lt;count; i++) </span><br><span class="line">         str = (*env)-&gt;NewStringUTF(env, &quot;0&quot;); </span><br><span class="line"> &#125; </span><br><span class="line">运行结果</span><br><span class="line"> JVMCI161: FATAL ERROR in native method: Out of memory when expanding </span><br><span class="line"> local ref table beyond capacity </span><br><span class="line"> at TestLocalReference.nativeMethod(Native Method) </span><br><span class="line"> at TestLocalReference.main(TestLocalReference.java:9) </span><br></pre></td></tr></table></figure>

<p>运行结果证明，JVM 运行异常终止，原因是创建了过多的 Local Reference，从而导致 out of memory。实际上，nativeMethod 在运行中创建了越来越多的 JNI Local Reference，而不是看似的始终只有一个。过多的 Local Reference，导致了 JNI 内部的 JNI Local Reference 表内存溢出。</p>
<h5 id="错误实例-2"><a href="#错误实例-2" class="headerlink" title="错误实例 2"></a>错误实例 2</h5><p>实例 2 是实例 1 的变种，Java 代码未作修改，但是 nativeMethod(int i) 的 C 语言实现稍作修改。在 JNI 的 native method 中实现的 utility 函数中创建 Java 的 String 对象。utility 函数只建立一个 String 对象，返回给调用函数，但是 utility 函数对调用者的使用情况是未知的，每个函数都可能调用它，并且同一函数可能调用它多次。在实例 2 中，nativeMethod 在循环中调用 count 次，utility 函数在创建一个 String 对象后即返回，并且会有一个退栈过程，似乎所创建的 Local Reference 会在退栈时被删除掉，所以应该不会有很多 Local Reference 被创建。实际运行结果并非如此。</p>
<p>清单 2. Local Reference 引发内存泄漏 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Java 代码部分参考实例 1，未做任何修改。</span><br><span class="line"></span><br><span class="line"> JNI 代码，nativeMethod(int i) 的 C 语言实现</span><br><span class="line"> #include&lt;stdio.h&gt; </span><br><span class="line"> #include&lt;jni.h&gt; </span><br><span class="line"> #include&quot;TestLocalReference.h&quot;</span><br><span class="line"> jstring CreateStringUTF(JNIEnv * env) </span><br><span class="line"> &#123; </span><br><span class="line"> return (*env)-&gt;NewStringUTF(env, &quot;0&quot;); </span><br><span class="line"> &#125; </span><br><span class="line"> JNIEXPORT void JNICALL Java_TestLocalReference_nativeMethod </span><br><span class="line"> (JNIEnv * env, jobject obj, jint count) </span><br><span class="line"> &#123; </span><br><span class="line"> jint i = 0; </span><br><span class="line"> for(; i&lt;count; i++) </span><br><span class="line"> &#123; </span><br><span class="line">         str = CreateStringUTF(env); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">运行结果</span><br><span class="line"> JVMCI161: FATAL ERROR in native method: Out of memory when expanding local ref </span><br><span class="line"> table beyond  capacity </span><br><span class="line"> at TestLocalReference.nativeMethod(Native Method) </span><br><span class="line"> at TestLocalReference.main(TestLocalReference.java:9) </span><br></pre></td></tr></table></figure>

<p>运行结果证明，实例 2 的结果与实例 1 的完全相同。过多的 Local Reference 被创建，仍然导致了 JNI 内部的 JNI Local Reference 表内存溢出。实际上，在 utility 函数 CreateStringUTF(JNIEnv * env)<br>执行完成后的退栈过程中，创建的 Local Reference 并没有像 native code 中的局部变量那样被删除，而是继续在 Local Reference 表中存在，并且有效。<em>Local Reference 和局部变量有着本质的区别。</em></p>
<h5 id="Local-Reference-深层解析"><a href="#Local-Reference-深层解析" class="headerlink" title="Local Reference 深层解析"></a>Local Reference 深层解析</h5><p>Java JNI 的文档规范只描述了 JNI Local Reference 是什么（存在的目的），以及应该怎么使用 Local Reference（开放的接口规范）。但是对 Java 虚拟机中 JNI Local Reference 的实现并没有约束，不同的 Java 虚拟机有不同的实现机制。这样的好处是，不依赖于具体的 JVM 实现，有好的可移植性；并且开发简单，规定了“应该怎么做、怎么用”。但是弊端是初级开发者往往看不到本质，“不知道为什么这样做”。对 Local Reference 没有深层的理解，就会在编程过程中无意识的犯错。<br><strong>Local Reference 和 Local Reference 表</strong><br>理解 Local Reference 表的存在是理解 JNI Local Reference 的关键。<br>JNI Local Reference 的生命期是在 native method 的执行期（从 Java 程序切换到 native code 环境时开始创建，或者在 native method 执行时调用 JNI function 创建），在 native method 执行完毕切换回 Java 程序时，所有 JNI Local Reference 被删除，生命期结束（调用 JNI function 可以提前结束其生命期）。<br>实际上，每当线程从 Java 环境切换到 native code 上下文时（J2N），JVM 会分配一块内存，创建一个 Local Reference 表，这个表用来存放本次 native method 执行中创建的所有的 Local Reference。每当在 native code 中引用到一个 Java 对象时，JVM 就会在这个表中创建一个 Local Reference。比如，实例 1 中我们调用 NewStringUTF() 在 Java Heap 中创建一个 String 对象后，在 Local Reference 表中就会相应新增一个 Local Reference。</p>
<p><strong>图 1. Local Reference 表、Local Reference 和 Java 对象的关系</strong><br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jnileak/image003.jpg" alt="enter image description here"><br>图 1 中：</p>
<ol>
<li>运行 native method 的线程的堆栈记录着 Local Reference 表的内存位置（指针 p）。</li>
<li> Local Reference 表中存放 JNI Local Reference，实现 Local Reference 到 Java 对象的映射。</li>
<li>native method 代码间接访问 Java 对象（java obj1，java obj2）。通过指针 p 定位相应的 Local Reference 的位置，然后通过相应的 Local Reference 映射到 Java 对象。</li>
<li>当 native method 引用一个 Java 对象时，会在 Local Reference 表中创建一个新 Local Reference。在 Local Reference 结构中写入内容，实现 Local Reference 到 Java 对象的映射。</li>
<li> native method 调用 DeleteLocalRef() 释放某个 JNI Local Reference 时，首先通过指针 p 定位相应的 Local Reference 在 Local Ref 表中的位置，然后从 Local Ref 表中删除该 Local Reference，也就取消了对相应 Java 对象的引用（Ref count 减 1）。</li>
<li> 当越来越多的 Local Reference 被创建，这些 Local Reference 会在 Local Ref 表中占据越来越多内存。当 Local Reference 太多以至于 Local Ref 表的空间被用光，JVM 会抛出异常，从而导致 JVM 的崩溃。<h5 id="Local-Ref-不是-native-code-的局部变量"><a href="#Local-Ref-不是-native-code-的局部变量" class="headerlink" title="Local Ref 不是 native code 的局部变量"></a>Local Ref 不是 native code 的局部变量</h5>很多人会误将 JNI 中的 Local Reference 理解为 Native Code 的局部变量。这是错误的。<br>Native Code 的局部变量和 Local Reference 是完全不同的，区别可以总结为：</li>
<li>局部变量存储在线程堆栈中，而 Local Reference 存储在 Local Ref 表中。</li>
<li>局部变量在函数退栈后被删除，而 Local Reference 在调用 DeleteLocalRef() 后才会从 Local Ref 表中删除，并且失效，或者在整个 Native Method 执行结束后被删除。</li>
<li>可以在代码中直接访问局部变量，而 Local Reference 的内容无法在代码中直接访问，必须通过 JNI function 间接访问。JNI function 实现了对 Local Reference 的间接访问，JNI function 的内部实现依赖于具体 JVM。<br>代码清单 1 中 str = (*env)-&gt;NewStringUTF(env, “0”);<br>str 是 jstring 类型的局部变量。Local Ref 表中会新创建一个 Local Reference，引用到 NewStringUTF(env, “0”) 在 Java Heap 中新建的 String 对象。如图 2 所示：</li>
</ol>
<h5 id="图-2-str-间接引用-string-对象"><a href="#图-2-str-间接引用-string-对象" class="headerlink" title="图 2. str 间接引用 string 对象"></a>图 2. str 间接引用 string 对象</h5><p><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jnileak/image005.jpg" alt="enter image description here"><br>图 2 中，str 是局部变量，在 native method 堆栈中。Local Ref3 是新创建的 Local Reference，在 Local Ref 表中，引用新创建的 String 对象。JNI 通过 str 和指针 p 间接定位 Local Ref3，但 p 和 Local Ref3 对 JNI 程序员不可见。</p>
<h5 id="Local-Reference-导致内存泄漏"><a href="#Local-Reference-导致内存泄漏" class="headerlink" title="Local Reference 导致内存泄漏"></a>Local Reference 导致内存泄漏</h5><p>在以上论述基础上，我们通过分析错误实例 1 和实例 2，来分析 Local Reference 可能导致的内存泄漏，加深对 Local Reference 的深层理解。<br>分析错误实例 1：<br>局部变量 str 在每次循环中都被重新赋值，间接指向最新创建的 Local Reference，前面创建的 Local Reference 一直保留在 Local Ref 表中。<br>在实例 1 执行完第 i 次循环后，内存布局如图 3：</p>
<p>图 3. 执行 i 次循环后的内存布局<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jnileak/image007.jpg" alt="图 3. 执行 i 次循环后的内存布局"><br>继续执行完第 i+1 次循环后，内存布局发生变化，如图 4：</p>
<p>图 4. 执行 i+1 次循环后的内存布局<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-jnileak/image009.jpg" alt="图 4. 执行 i+1 次循环后的内存布局"><br>图 4 中，局部变量 str 被赋新值，间接指向了 Local Ref i+1。在 native method 运行过程中，我们已经无法释放 Local Ref i 占用的内存，以及 Local Ref i 所引用的第 i 个 string 对象所占据的 Java Heap 内存。所以，native memory 中 Local Ref i 被泄漏，Java Heap 中创建的第 i 个 string 对象被泄漏了。<br>也就是说在循环中，前面创建的所有 i 个 Local Reference 都泄漏了 native memory 的内存，创建的所有 i 个 string 对象都泄漏了 Java Heap 的内存。<br>直到 native memory 执行完毕，返回到 Java 程序时（N2J），这些泄漏的内存才会被释放，但是 Local Reference 表所分配到的内存往往很小，在很多情况下 N2J 之前可能已经引发严重内存泄漏，导致 Local Reference 表的内存耗尽，使 JVM 崩溃，例如错误实例 1。<br>分析错误实例 2：<br>实例 2 与实例 1 相似，虽然每次循环中调用工具函数 CreateStringUTF(env) 来创建对象，但是在 CreateStringUTF(env) 返回退栈过程中，只是局部变量被删除，而每次调用创建的 Local Reference 仍然存在 Local Ref 表中，并且有效引用到每个新创建的 string 对象。str 局部变量在每次循环中被赋新值。<br>这样的内存泄漏是潜在的，但是这样的错误在 JNI 程序员编程过程中却经常出现。通常情况，在触发 out of memory 之前，native method 已经执行完毕，切换回 Java 环境，所有 Local Reference 被删除，问题也就没有显露出来。但是某些情况下就会引发 out of memory，导致实例 1 和实例 2 中的 JVM 崩溃。</p>
<h4 id="控制-Local-Reference-生命期"><a href="#控制-Local-Reference-生命期" class="headerlink" title="控制 Local Reference 生命期"></a>控制 Local Reference 生命期</h4><p>因此，在 JNI 编程时，正确控制 JNI Local Reference 的生命期。如果需要创建过多的 Local Reference，那么在对被引用的 Java 对象操作结束后，需要调用 JNI function（如 DeleteLocalRef()），及时将 JNI Local Reference 从 Local Ref 表中删除，以避免潜在的内存泄漏。<br>回页首</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文阐述了 JNI 编程可能引发的内存泄漏，JNI 编程既可能引发 Java Heap 的内存泄漏，也可能引发 native memory 的内存泄漏，严重的情况可能使 JVM 运行异常终止。JNI 软件开发人员在编程中，应当考虑以下几点，避免内存泄漏：</p>
<blockquote>
<p>native code 本身的内存管理机制依然要遵循。<br>使用 Global reference 时，当 native code 不再需要访问 Global reference 时，应当调用 JNI 函数 DeleteGlobalRef() 删除 Global reference 和它引用的 Java 对象。Global reference 管理不当会导致 Java Heap 的内存泄漏。<br>透彻理解 Local reference，区分 Local reference 和 native code 的局部变量，避免混淆两者所引起的 native memory 的内存泄漏。<br>使用 Local reference 时，如果 Local reference 引用了大的 Java 对象，当不再需要访问 Local reference 时，应当调用 JNI 函数 DeleteLocalRef() 删除 Local reference，从而也断开对 Java 对象的引用。这样可以避免 Java Heap 的 out of memory。<br>使用 Local reference 时，如果在 native method 执行期间会创建大量的 Local reference，当不再需要访问 Local reference 时，应当调用 JNI 函数 DeleteLocalRef() 删除 Local reference。Local reference 表空间有限，这样可以避免 Local reference 表的内存溢出，避免 native memory 的 out of memory。<br>严格遵循 Java JNI 规范书中的使用规则。</p>
</blockquote>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/renxianzuo/article/details/6824716">jni 内存泄露</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/04/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E4%B8%89-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/04/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E4%B8%89-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/" class="post-title-link" itemprop="url">Android JNI开发步骤三(数据传递)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-04 21:32:02" itemprop="dateCreated datePublished" datetime="2021-05-04T21:32:02+08:00">2021-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 18:02:01" itemprop="dateModified" datetime="2021-09-09T18:02:01+08:00">2021-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<p>首先JNI中的数据类型有基本数据类型和引用类型：<br>基本数据类型为：</p>
<table>
<thead>
<tr>
<th align="center">Java</th>
<th align="center">native</th>
<th align="center">Size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">jboolean</td>
<td align="center">unsigned 8 bits</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">jbyte</td>
<td align="center">signed 8 bits</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">jchar</td>
<td align="center">unsigned 16 bits</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">jshort</td>
<td align="center">signed 16 bits</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">jint</td>
<td align="center">signed 32 bits</td>
</tr>
<tr>
<td align="center">lon g</td>
<td align="center">jlong</td>
<td align="center">signed 64 bits</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">jfloat</td>
<td align="center">32 bits</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">jdouble</td>
<td align="center">64 bits</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">void</td>
<td align="center">void</td>
</tr>
</tbody></table>
<h4 id="1-字符串传递"><a href="#1-字符串传递" class="headerlink" title="1. 字符串传递"></a>1. 字符串传递</h4><h5 id="从Java传递到native代码"><a href="#从Java传递到native代码" class="headerlink" title="从Java传递到native代码"></a>从Java传递到native代码</h5><p>首先，Java代码：</p>
<pre><code>public native String sumStr(String strA,String strB);  
</code></pre>
<p>然后，native方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_example_mystore_MainActivity_sumStr(  </span><br><span class="line">        JNIEnv * pJNIEnv, jobject pThis, jstring a, jstring b) &#123;  </span><br><span class="line">    //将Java层的字符串转成char*类型的</span><br><span class="line">    const char* aString = (*pJNIEnv)-&gt;GetStringUTFChars(pJNIEnv, a, 0);  </span><br><span class="line">    const char* bString = (*pJNIEnv)-&gt;GetStringUTFChars(pJNIEnv, b, 0);  </span><br><span class="line">    //之后就可以进行相应的处理</span><br><span class="line">    char* buf[1024];  </span><br><span class="line">    strcpy(buf, aString);  </span><br><span class="line">    strcat(buf, bString);  </span><br><span class="line">    (*pJNIEnv)-&gt;ReleaseStringUTFChars(pJNIEnv, a, aString);  </span><br><span class="line">    (*pJNIEnv)-&gt;ReleaseStringUTFChars(pJNIEnv, b, bString);  </span><br><span class="line">    return (*pJNIEnv)-&gt;NewStringUTF(pJNIEnv, buf);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>由于java程序中传过去的String对象在本地方法中对应的是jstring类型，jstring类型和c中的char<em>不同，所以如果你直接当做 char</em>使用的话，就会出错。因此在使用之前需要将jstring转换成为c/c++中的char*，这里使用JNIEnv的方法转换。 </p>
<h5 id="从native传递字符串到java"><a href="#从native传递字符串到java" class="headerlink" title="从native传递字符串到java"></a>从native传递字符串到java</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//处理字符串追加  </span><br><span class="line">JNIEXPORT jstring JNICALL Java_cn_itcast_ndk3_DataProvider_sayHelloInC  </span><br><span class="line">  (JNIEnv * env, jobject obj, jstring str)&#123;  </span><br><span class="line">    char* newstr = &quot;native string&quot;;   </span><br><span class="line">    return (*env)-&gt;NewStringUTF(env, newstr);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="2-传递基本类型数据"><a href="#2-传递基本类型数据" class="headerlink" title="2.传递基本类型数据"></a>2.传递基本类型数据</h4><p>很多情况下，比如图片数据处理，我们都需要将图像数据以数据的形式，传递到native代码中进行相应的处理，然后在传递回java层。</p>
<h5 id="Java层传递到native层"><a href="#Java层传递到native层" class="headerlink" title="Java层传递到native层"></a>Java层传递到native层</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//处理Java传过来的char[]</span><br><span class="line"> jcharArray test_chararray (JNIEnv * env, jclass, jcharArray j_char_array)&#123; </span><br><span class="line">//首先计算数组长度 </span><br><span class="line">    jsize j_char_array_size = env-&gt;GetArrayLength(j_char_array);  </span><br><span class="line">    //获取数据第一个数据的地址</span><br><span class="line">    jchar* j_c = env-&gt;GetCharArrayElements(j_char_array, 0);  </span><br><span class="line">    //打印</span><br><span class="line">      for (int i = 0; i &lt; j_char_array_size; i++)&#123;  </span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO, COM_THINKING_J_DATA_TOOLS_LOG_TITLE, &quot;array index %i is %i from %x&quot;, i, *(j_c + i), (j_c + i));  </span><br><span class="line">        if (*(j_c + i) &gt;= 97 &amp;&amp; *(j_c + i) &lt;= 122)&#123;  </span><br><span class="line">            *(j_c + i) -= 32;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">    //接下来是在本地接收</span><br><span class="line">    //先创建一个相同大小的数组 </span><br><span class="line">    jcharArray result_array = env-&gt;NewCharArray(j_char_array_size);</span><br><span class="line">    //获取新创建的的数组的第一个数据的地址  ，其实也就是相当于获取到了全部的数据</span><br><span class="line">    //第一个是数组，第二个是数组里面开始的元素</span><br><span class="line">    jchar * result = env-&gt;GetCharArrayElements(result_array, 0);  </span><br><span class="line">    if (j_char_array_size &gt; 0)&#123;  </span><br><span class="line">    //复制到新的数据中，第一个参数是目的数组，第二个是源数组，第三个是size</span><br><span class="line">        memcpy(result, j_c, j_char_array_size*sizeof(jchar));  </span><br><span class="line">    &#125;  </span><br><span class="line">    //释放</span><br><span class="line">    env-&gt;ReleaseCharArrayElements(j_char_array, j_c, 0);  </span><br><span class="line">    env-&gt;ReleaseCharArrayElements(result_array, result, 0);  </span><br><span class="line">    return result_array;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//另一个处理方法,处理Java过来的int[]</span><br><span class="line">jint IntArray_sumArray(JNIEnv *env, jobject obj, jintArray arr)</span><br><span class="line"> &#123;</span><br><span class="line">     jint buf[10];</span><br><span class="line">     jint i, sum = 0;</span><br><span class="line">     //从0开始复制长度为10的数据从arr到buf中</span><br><span class="line">     (*env)-&gt;GetIntArrayRegion(env, arr, 0, 10, buf);</span><br><span class="line">     for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">         sum += buf[i];</span><br><span class="line">     &#125;</span><br><span class="line">     return sum;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//处理Java传过来的byte[]</span><br><span class="line">jboolean  processByteArray(JNIEnv *env, jobject object,jbyteArray passwd,jint len)</span><br><span class="line">&#123;</span><br><span class="line">   jbyte *bytes;</span><br><span class="line">   unsigned char *buf;</span><br><span class="line">   int i;</span><br><span class="line">    //从jbytearray获取数据到jbyte*</span><br><span class="line">   bytes = env-&gt;GetByteArrayElements(passwd,NULL);</span><br><span class="line">   if(bytes == NULL) &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">   buf =(unsigned char *)calloc(len,sizeof(char));</span><br><span class="line">   if(buf == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">   for(i=0;i&lt;len;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      *(buf+i)=(unsigned char)(*(bytes+i));</span><br><span class="line">   &#125;</span><br><span class="line">    //释放资源</span><br><span class="line">   env-&gt;ReleaseByteArrayElements(passwd,bytes,0);</span><br><span class="line">   __android_log_write(ANDROID_LOG_ERROR,&quot;TAG&quot;,(char*)buf);</span><br><span class="line">   free(buf);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我们可以看到，native中有两种方法可以接收Java传过来的数组：一个 GetByteArrayRegion，另一个是 GetByteArrayElements ，前者是进行值拷贝，将Java端数组的数据拷贝到本地的数组中，后者是指针的形式，将本地的数组指针直接指向Java端的数组地址，其实本质上是JVM在堆上分配的这个数组对象上增加一个引用计数，保证垃圾回收的时候不要释放，从而交给本地的指针使用，使用完毕后指针一定要记得通过ReleaseByteArrayElements进行释放，否则会产生内存泄露</strong></p>
<h5 id="native返回数组值Java层"><a href="#native返回数组值Java层" class="headerlink" title="native返回数组值Java层"></a>native返回数组值Java层</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//传递jintArray 到java</span><br><span class="line">JNIEXPORT jintArray JNICALL getIntArray(JNIEnv * pJNIEnv, jobject pThis) &#123;  </span><br><span class="line">    //  先创建  </span><br><span class="line">    jintArray lJavaArray = (*pJNIEnv)-&gt;NewIntArray(pJNIEnv, 4);  </span><br><span class="line">    if (lJavaArray == NULL) &#123;  </span><br><span class="line">        return NULL;  </span><br><span class="line">    &#125;  </span><br><span class="line">    int target[] = &#123; 2, 4, 6, 8 &#125;;  </span><br><span class="line">    //从target复制从0开始长度为4的数组，到lJavaArray中</span><br><span class="line">    (*pJNIEnv)-&gt;SetIntArrayRegion(pJNIEnv, lJavaArray, 0, 4, target);  </span><br><span class="line">    return lJavaArray;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//向Java层返回Byte数组</span><br><span class="line">JNIEXPORT jintArray JNICALL setByteArray(JNIEnv * pJNIEnv, jobject pThis) &#123;  </span><br><span class="line">    unsigned char buffer[10];</span><br><span class="line">    jbytearray array = env-&gt;NewByteArray(10);//创建一个新的bytearray，长度为10</span><br><span class="line">    for(int i = 0;i &lt; 10; i++)&#123;</span><br><span class="line">        buffer[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //从buffer复制从0开始长度为4的数组，到array中</span><br><span class="line">    env-&gt;SetByteArrayRegion(array,0,10,buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-JNI和Java共享内存空间"><a href="#3-JNI和Java共享内存空间" class="headerlink" title="3.JNI和Java共享内存空间"></a>3.JNI和Java共享内存空间</h4><p>首先，对上面的几种类型做一些总结： </p>
<h5 id="1-Java传到JNI，使用GetByteArrayRegion的方式："><a href="#1-Java传到JNI，使用GetByteArrayRegion的方式：" class="headerlink" title="1. Java传到JNI，使用GetByteArrayRegion的方式："></a>1. Java传到JNI，使用GetByteArrayRegion的方式：</h5><p>该方法的本质是将Java端数组数据拷贝到本地的数组中，所以在JNI对数据修改后Java端的数据并没有改变。 使用GetPrimitiveArrayCritical。<br>GetPrimitiveArrayCritical 表面上可以得到底层数据指针，在JNI层修改数组时Java层的数据也会变。But，如果只使用GetPrimitiveArrayCritical获取数据，程序运行一段时间内存会crash。所以，使用GetPrimitiveArrayCritical时必须使用ReleasePrimitiveArrayCritical ，通过测试发现当数据量大时执行ReleasePrimitiveArrayCritical会非常耗时。 </p>
<h5 id="2-JNI传到Java："><a href="#2-JNI传到Java：" class="headerlink" title="2. JNI传到Java："></a>2. JNI传到Java：</h5><p>把Jni层的数组传递到Java层，一般有两种方法，一种是通过native函数的返回值来传递，另一种是通过jni层回调java层的函数来传递，后者多用于jni的线程中或是数据量较大的情况。无论哪种方法，都离不开 SetByteArrayRegion 函数，该函数将本地的数组数据拷贝到了 Java 端的数组中。<br><strong>请注意，上面的方式都涉及到内存复制，根据实战经验，在Android系统中，一旦数据量变大，拷贝一次内存将非常耗时。所以上述方式在追求效率时不推荐使用。解决的方法可以尝试让JAVA层和JNI共享内存的方式。最后找到了两种方式。</strong></p>
<h5 id="使用共享内存的方式"><a href="#使用共享内存的方式" class="headerlink" title="使用共享内存的方式"></a>使用共享内存的方式</h5><h5 id="1-使用GetByteArrayElements方式"><a href="#1-使用GetByteArrayElements方式" class="headerlink" title="1. 使用GetByteArrayElements方式"></a>1. 使用GetByteArrayElements方式</h5><p>该方式是指针的形式，将本地的数组指针直接指向Java端的数组地址，其实本质上是JVM在堆上分配的这个数组对象上增加一个引用计数，保证垃圾回收的时候不要释放，从而交给本地的指针使用，使用完毕后指针一定要记得通过ReleaseByteArrayElements进行释放，否则会产生内存泄露。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned char* psrcImg = (unsigned char*)(env-&gt;GetByteArrayElements(srcImg,0));  </span><br><span class="line">unsigned char* pBufferI420 = (unsigned char*) (env-&gt;GetByteArrayElements(dstImg,0));</span><br><span class="line"></span><br><span class="line">if (psrcImg == NULL || pBufferI420 == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;ReleaseByteArrayElements(srcImg,(jbyte*)psrcImg,0);</span><br><span class="line">env-&gt;ReleaseByteArrayElements(dstImg,(jbyte*)pBufferI420,0);</span><br></pre></td></tr></table></figure>
<h5 id="2-使用Direct-Buffer-方式传递"><a href="#2-使用Direct-Buffer-方式传递" class="headerlink" title="2. 使用Direct Buffer 方式传递"></a>2. 使用Direct Buffer 方式传递</h5><p>Java和Jni层的数组传递还有一个比较重要的方式，就是通过Direct Buffer来传递，这种方式类似于在堆上创建创建了一个Java和Jni层共享的整块内存区域，无论是Java层或者Jni层均可访问这块内存，并且Java端与Jni端同步变化，由于是采用的是共享内存的方式，因此相比于普通的数组传递，效率更高，但是由于构造/析构/维护这块共享内存的代价比较大，所以小数据量的数组建议还是采用上述方式，Direct Buffer方式更适合长期使用频繁访问的大块内存的共享。具体可使用GetDirectBufferAddress获得共享的内存地址。<br>比如在涉及到RTSP获取预览图像数据的时候，需要一帧一帧的发送到Java，就可以使用这种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JNIEnv *env ;</span><br><span class="line">if (savedVm-&gt;AttachCurrentThread(&amp;env, 0) != 0)</span><br><span class="line">&#123;</span><br><span class="line">    LOGI(&quot;Failed to attach current thread&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">//第一个参数是数据，类型为void*，第二个为数据大小</span><br><span class="line">jobject buf = env-&gt;NewDirectByteBuffer(frame_mjpeg-&gt;data, frame_mjpeg-&gt;actual_bytes);</span><br><span class="line">//调起Java的方法，作为参数传入</span><br><span class="line">env-&gt;CallVoidMethod(mObject, on_new_frame_method_id,buf);</span><br><span class="line">env-&gt;ExceptionClear();</span><br><span class="line">env-&gt;DeleteLocalRef(buf);</span><br><span class="line">savedVm-&gt;DetachCurrentThread();</span><br></pre></td></tr></table></figure>
<p><em><strong>在JNI层，尽量避免使用内存拷贝。</strong></em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/03/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/03/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E4%B8%80/" class="post-title-link" itemprop="url">Android JNI开发步骤一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-03 21:57:17" itemprop="dateCreated datePublished" datetime="2021-05-03T21:57:17+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 18:02:01" itemprop="dateModified" datetime="2021-09-09T18:02:01+08:00">2021-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span> 

<h4 id="1-JNI中获取JavaVM和-JNIEnv"><a href="#1-JNI中获取JavaVM和-JNIEnv" class="headerlink" title="1. JNI中获取JavaVM和 JNIEnv"></a>1. JNI中获取JavaVM和 JNIEnv</h4><p>JavaVM是虚拟机在JNI中的表示，一个虚拟机中只有一个JavaVM对象，这个对象是线程共享的。<br>JNIEnv类型是一个指向全部JNI方法的指针。该指针只在创建它的线程有效，不能跨线程传递。多线程无法共享。<br>使用JNI_OnLoad方法，这个方法需要自己实现。如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jint JNI_OnLoad(JavaVM *vm,void *reserved)&#123;</span><br><span class="line">    LOGE(&quot;JNI_Onload in 1&quot;);</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    int result = -1;</span><br><span class="line">    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">    LOGE(&quot;JNI_Onload in 2&quot;);</span><br><span class="line">        return JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    result = register_method(env);//动态注册本地方法</span><br><span class="line">    savedVm = vm;//保存JavaVM ，供其他地方使用。</span><br><span class="line">    LOGE(&quot;JNI_Onload in 3 , result is %d&quot;, result);</span><br><span class="line">    return JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是在加载相应的.so包的时候，系统主动调用的，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        System.loadLibrary(&quot;native-lib&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这句代码调用时，JNI_OnLoad方法就会被调用。<br>每一个.so文件中，只能包含一个JNI_OnLoad方法，也就是在当前.so包含的文件中，只能有一个.c文件中实现这个JNI_OnLoad方法。<br>如上面的做法，我们可以在头文件中声明extern JavaVM *savedVm;，然后其他文件include这个头文件后，就可以使用这个JavaVM。<br>很多情况下，我们需要在其他文件中的一个多线程中使用JNIEnv，比如在线程中使用FindClass方法，这个时候，我们就可以通过JavaVM对象来获取JNIEnv，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEnv *env ;</span><br><span class="line">if (savedVm-&gt;AttachCurrentThread(&amp;env, 0) != 0)</span><br><span class="line">&#123;</span><br><span class="line">	LOGI(&quot;Failed to attach current thread&quot;);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AttachCurrentThread表示当前线程与JVM进行关联，这样才能获取到JNIEnv对象；<br>这样我们就可以在多线程中使用JNIEnv对象，然后使用FindClass方法。当然，使用完了需要解除当前线程和虚拟机的关联，savedVm-&gt;DetachCurrentThread();，不然会报异常。<br>还可以在应用退出时，卸载当前虚拟机.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jint DestroyJavaVM(JavaVM* vm);</span><br></pre></td></tr></table></figure>
<h4 id="2、动态注册JNI方法"><a href="#2、动态注册JNI方法" class="headerlink" title="2、动态注册JNI方法"></a>2、动态注册JNI方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">jint JNI_OnLoad(JavaVM *vm,void *reserved)&#123;</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    int result = -1;</span><br><span class="line">    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">    LOGE(&quot;JNI_Onload in 2&quot;);</span><br><span class="line">        return JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    **result = register_method(env);//动态注册本地方法**</span><br><span class="line">    savedVm = vm;//保存JavaVM ，供其他地方使用。</span><br><span class="line">    LOGE(&quot;JNI_Onload in 3 , result is %d&quot;, result);</span><br><span class="line">    return JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line">//这是本地方法的一个集合</span><br><span class="line">JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;&quot;helloMethod&quot;,&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,(void*)helloMethod&#125;,</span><br><span class="line">    &#123;&quot;nativeCallJava&quot;,&quot;()V&quot;,(void*)nativeCallJava&#125;,</span><br><span class="line">    &#123;&quot;nativeCallJavaInThread&quot;,&quot;()V&quot;,(void*)nativeCallJavaInThread&#125;</span><br><span class="line">&#125;;</span><br><span class="line">jint register_method(JNIEnv *env)&#123;</span><br><span class="line">//开始注册方法</span><br><span class="line">    int result = registerNativeMethods(env,&quot;com/xxxx/jni/MainActivity&quot;,methods, sizeof(methods) / sizeof(methods[0]));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jint registerNativeMethods(JNIEnv* env, const char *class_name, JNINativeMethod *methods, int num_methods) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    //先根据类名找到类，这个类一般是用来存放所有的native方法</span><br><span class="line">    jclass clazz = env-&gt;FindClass(class_name);</span><br><span class="line">    if(clazz == NULL)&#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用JNI方法，注册方法</span><br><span class="line">    result = env-&gt;RegisterNatives(clazz, methods, num_methods);</span><br><span class="line">    if(result &lt; 0)&#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JNINativeMethod结构体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">const char* name;  </span><br><span class="line">const char* signature;  </span><br><span class="line">void* fnPtr;  </span><br><span class="line">&#125; JNINativeMethod;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个变量name是Java中函数的名字。<br>第二个变量signature，用字符串是描述了Java中函数的参数和返回值<br>第三个变量fnPtr是函数指针，指向native函数。前面都要接 (void *)<br>第一个变量与第三个变量是对应的，一个是java层方法名，对应着第三个参数&gt;的native方法名字<br>关于第二个变量，表示的参数和返回值表示，可以看如下：</p>
</blockquote>
<h5 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h5><table>
<thead>
<tr>
<th align="center">java</th>
<th align="center">native</th>
<th align="center">signature</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">jchar</td>
<td align="center">C</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">jbyte</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">jshort</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">jint</td>
<td align="center">I</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">jlong</td>
<td align="center">L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">jfloat</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">jdouble</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">jboolean</td>
<td align="center">Z</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">void</td>
<td align="center">V</td>
</tr>
</tbody></table>
<h5 id="引用数据类型的转换"><a href="#引用数据类型的转换" class="headerlink" title="引用数据类型的转换"></a>引用数据类型的转换</h5><table>
<thead>
<tr>
<th align="center">java</th>
<th align="center">native</th>
<th align="center">signature</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所有对象</td>
<td align="center">jobject</td>
<td align="center">L+classname +;</td>
</tr>
<tr>
<td align="center">Class</td>
<td align="center">jclass</td>
<td align="center">Ljava/lang/Class;</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">jstring</td>
<td align="center">Ljava/lang/String;</td>
</tr>
<tr>
<td align="center">Throwable</td>
<td align="center">jthrowable</td>
<td align="center">Ljava/lang/Throwable;</td>
</tr>
<tr>
<td align="center">Object[]</td>
<td align="center">jobjectArray</td>
<td align="center">[L+classname +;</td>
</tr>
<tr>
<td align="center">byte[]</td>
<td align="center">jbyteArray</td>
<td align="center">[B</td>
</tr>
<tr>
<td align="center">char[]</td>
<td align="center">jcharArray</td>
<td align="center">[C</td>
</tr>
<tr>
<td align="center">double[]</td>
<td align="center">jdoubleArray</td>
<td align="center">[D</td>
</tr>
<tr>
<td align="center">float[]</td>
<td align="center">jfloatArray</td>
<td align="center">[F</td>
</tr>
<tr>
<td align="center">int[]</td>
<td align="center">jintArray</td>
<td align="center">[I</td>
</tr>
<tr>
<td align="center">short[]</td>
<td align="center">jshortArray</td>
<td align="center">[S</td>
</tr>
<tr>
<td align="center">long[]</td>
<td align="center">jlongArray</td>
<td align="center">[J</td>
</tr>
<tr>
<td align="center">boolean[]</td>
<td align="center">jbooleanArray</td>
<td align="center">[Z</td>
</tr>
</tbody></table>
<blockquote>
<p>从上表可一看出，数组的JNI层数据类型需要以“Array”结尾，签名格式的开头都会有“[”。除了数组以外，其他的引用数据类型的签名格式都会以“;”结尾。</p>
</blockquote>
<p>当然，我们也可以在应用退出时卸载本地方法。JNI_OnLoad方法是在动态库被加载时调用，而JNI_OnUnload则是在本地库被卸载时调用。所以这两个函数就是一个本地库最重要的两个生命周期方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int unRegisterNative(JNIEnv *env) &#123;</span><br><span class="line">    jclass clazz = env-&gt;FindClass(“类名”);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return env-&gt;UnregisterNatives(clazz) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JNI_OnUnload(JavaVM *vm, void *reserved) &#123;</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    jint result = -1;</span><br><span class="line">    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int ret = unRegisterNative(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/03/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's personal blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/03/Android-JNI%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E4%BA%8C/" class="post-title-link" itemprop="url">Android JNI开发步骤二（native 调用java 方法）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-03 21:08:27" itemprop="dateCreated datePublished" datetime="2021-05-03T21:08:27+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-10 14:39:24" itemprop="dateModified" datetime="2021-09-10T14:39:24+08:00">2021-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span> 

<p>在JNI代码中获取到了我们想要的值，需要返回到Java层，简单的情况下可以使用return某个值来实现。但是复杂情况下，我们需要不断地获取JNI中返回的值，我们就可以在JNI中主动去找Java中的方法，然后调用，并把JNI中的值作为Java方法的参数传入。如下：</p>
<p>//native方法将调用Java方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT void JNICALL nativeCallJava(JNIEnv *env, jobject thiz)&#123;</span><br><span class="line">    object_global = (jobject)env-&gt;NewGlobalRef(thiz);</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    //先获取JNIEnv</span><br><span class="line">    if (savedVm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        env = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //再通过FindClass来加载当前需要的类</span><br><span class="line">    jclass clazz = env-&gt;FindClass(&quot;com/XXXX/jni/MainActivity&quot;);</span><br><span class="line">    //获取当前类中的静态方法</span><br><span class="line">    jmethodID method1 = env-&gt;GetStaticMethodID(clazz,&quot;nativeCall&quot;,&quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">    jstring result = env-&gt;NewStringUTF(&quot;aaaaaaaaa&quot;);//字符串</span><br><span class="line">    env-&gt;CallStaticVoidMethod (clazz, method1,result);//调用静态方法</span><br><span class="line">    //获取普通成员方法</span><br><span class="line">    jmethodID method2 = env-&gt;GetMethodID(clazz,&quot;nativeCall_nonStatic&quot;,&quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">    //调用成员方法，这个时候第一个参数应该是对象</span><br><span class="line">    env-&gt;CallVoidMethod (thiz, method2,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是借用JNI主动传进来的jobject ，它就代表对应的Java类的对象。然而有时候，我们没有这样的对象引用作为参数，就需要找到Java的对应的构造器获取Java类的一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//调用java的静态方法</span><br><span class="line">NIEXPORT void JNICALL callJavaStaticMethod (JNIEnv *env, jclass cls)  </span><br><span class="line">&#123;  </span><br><span class="line">    jclass clazz = NULL;  </span><br><span class="line">    jstring str_arg = NULL;  </span><br><span class="line">    jmethodID mid_static_method;  </span><br><span class="line">    // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span><br><span class="line">    clazz =(*env)-&gt;FindClass(env,&quot;com/study/jnilearn/ClassMethod&quot;);  </span><br><span class="line">    if (clazz == NULL) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 2、从clazz类中查找callStaticMethod方法  </span><br><span class="line">    mid_static_method = (*env)-&gt;GetStaticMethodID(env,clazz,&quot;callStaticMethod&quot;,&quot;(Ljava/lang/String;I)V&quot;);  </span><br><span class="line">    if (mid_static_method == NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到callStaticMethod这个静态方法。&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 3、调用clazz类的callStaticMethod静态方法  </span><br><span class="line">    str_arg = (*env)-&gt;NewStringUTF(env,&quot;我是静态方法&quot;);  </span><br><span class="line">    //调用Java的静态方法不需要Java类的对象。后面需要传入参数。</span><br><span class="line">    (*env)-&gt;CallStaticVoidMethod(env,clazz,mid_static_method, str_arg, 100);  </span><br><span class="line">    // 删除局部引用  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 调用java的实例方法 </span><br><span class="line"> */  </span><br><span class="line">JNIEXPORT void JNICALL callJavaInstaceMethod  (JNIEnv *env, jclass cls)  </span><br><span class="line">&#123;  </span><br><span class="line">    jclass clazz = NULL;  </span><br><span class="line">    jobject jobj = NULL;  </span><br><span class="line">    jmethodID mid_construct = NULL;  </span><br><span class="line">    jmethodID mid_instance = NULL;  </span><br><span class="line">    jstring str_arg = NULL;  </span><br><span class="line">    // 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span><br><span class="line">    clazz = (*env)-&gt;FindClass(env, &quot;com/study/jnilearn/ClassMethod&quot;);  </span><br><span class="line">    if (clazz == NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到&#x27;com.study.jnilearn.ClassMethod&#x27;这个类&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 2、获取类的默认构造方法ID  ，没有参数</span><br><span class="line">    mid_construct = (*env)-&gt;GetMethodID(env,clazz, &quot;&lt;init&gt;&quot;,&quot;()V&quot;);  </span><br><span class="line">    if (mid_construct == NULL) &#123;  </span><br><span class="line">        printf(&quot;找不到默认的构造方法&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 3、查找实例方法的ID  ，第三个参数传入java方法的名称。第四个是方法参数表达式</span><br><span class="line">    mid_instance = (*env)-&gt;GetMethodID(env, clazz, &quot;callInstanceMethod&quot;, &quot;(Ljava/lang/String;I)V&quot;);  </span><br><span class="line">    if (mid_instance == NULL) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 4、创建该类的实例  </span><br><span class="line">    jobj = (*env)-&gt;NewObject(env,clazz,mid_construct);  </span><br><span class="line">    if (jobj == NULL) &#123;  </span><br><span class="line">        printf(&quot;在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 5、调用对象的实例方法  </span><br><span class="line">    str_arg = (*env)-&gt;NewStringUTF(env,&quot;我是实例方法&quot;);  //创建字符串的方法</span><br><span class="line">    (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200);  //调用方法，需要传入参数</span><br><span class="line"></span><br><span class="line">    // 删除局部引用  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,jobj);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </span><br></pre></td></tr></table></figure>

<p>以上在创建Java类的对象的时候，调用的默认的无参数构造器，如果调用的是有参数的构造器，就需要一下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取Student的jclass</span><br><span class="line">    jclass  studentClass=env-&gt;FindClass(&quot;com/xxxx/Student&quot;);</span><br><span class="line">    //获取Student的构造方法ID</span><br><span class="line">    jmethodID  studentCont=env-&gt;GetMethodID(studentClass,&quot;&lt;init&gt;&quot;,&quot;(Ljava/lang/String;I)V&quot;);</span><br><span class="line">    //实例化Student并传递参数</span><br><span class="line">    jstring name = env-&gt;NewStringUTF(&quot;JIN 构造方法新建对象 宝强&quot;);</span><br><span class="line">    jint age=30;</span><br><span class="line">    //创建Student的对象，需要传入参数</span><br><span class="line">    jobject student= env-&gt;NewObject(studentClass,studentCont,name,age);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/" title="GitHub → https:&#x2F;&#x2F;github.com" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/luoqingfeng5918@gmail.com" title="E-Mail → luoqingfeng5918@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
